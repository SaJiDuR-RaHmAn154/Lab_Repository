{
	"boilerplate": {
	"prefix": "boilerplate code",
	"body": [
	  "#include<bits/stdc++.h>",
	  "//#include<ext/pb_ds/assoc_container.hpp>",
	  "#include<ext/pb_ds/tree_policy.hpp>",
	  "#pragma GCC optimize(\"Ofast,unroll-loops\")",
	  "using namespace std;",
	  "using namespace __gnu_pbds;\n",

	  "",
      "//Primitive Data Type",
	  "typedef long long ll;",
	  "typedef long double ld;",
	  "typedef unsigned long long ull;",
	  
	  "",
	  "//STL",
	  "#define umap unordered_map",
	  "#define uset unordered_set",
	  "#define sz(v) (int)v.size()",
	  "#define vi vector<int>",
	  "#define vll vector<ll>",
	  "#define vvi vector<vi>",
	  "#define vvl vector<vl>",
	  "#define vs vector<string>",
	  "#define pii pair<int,int>",
	  "#define pll pair<ll,ll>",
	  "#define vpii vector<pii>",
	  "#define vpll vector<pll>",
	  "#define mi map<int,int>",
	  "#define mll map<ll,ll>",
	  "#define pb push_back",
	  "#define eb emplace_back",
	  "#define pob pop_back",
	  "#define pf pop_front",
	  "#define mp make_pair",
	  "#define ff first",
	  "#define ss second",
	  "#define nl '\\n'",
	  "#define fo(i,a,b) for(int i=a;i<b;++i)",
	  "#define re(i,a,b) for(int i=a;i>=b;--i)",
	  "#define itr(it, v) for(auto it = v.begin(); it != v.end(); it++)",
	  "#define fr(x, v) for(auto &x:v)",
	  "#define all(v) v.begin(),v.end()",
	  "#define rev(v) reverse(all(v))",
	  "#define srt(v) sort(all(v))",
	  "#define grtsrt(v) sort(all(v),greater<ll>())",
	  "#define tl(v)  transform(all(v),v.begin(),::tolower)",
	  "#define tu(v)  transform(all(v),v.begin(),::toupper)",
	  "#define lb(v,x) *lower_bound(all(v),x)",
	  "#define ub(v,x) *upper_bound(all(v),x)",
	  "#define mn(v) *min_element(all(v))",
	  "#define mx(v) *max_element(all(v))",
	  "#define mem(a,x) memset(a,x,sizeof(a))",
	  
	  "",
	  "//Bit Operations",
	  "#define set_bit(x,k) (x|=(1LL<<k))",
	  "#define uset_bit(x,k) (x &= ~(1LL<<k))",
	  "#define check_bit(x,k) (x & (1LL<<k))",
	  "#define toggle_bit(x,k) (x ^ (1LL<<k))",
	  "#define one(x) __builtin_popcountll(x)",
	  "#define zero(x) __builtin_clz(x)",
	  "inline ll binaryToDecimal(string n){string num = n;ll dec_value = 0;int base = 1;int len = num.length();for(int i = len - 1; i >= 0; i--){if (num[i] == '1')dec_value += base;base = base * 2;}return dec_value;}",
	  "inline string decToBinary(int n){string s=\"\";int i = 0;while (n > 0) {s =to_string(n % 2)+s;n = n / 2;i++;}return s;}",
	
      "",
	  "//Input_Output",
	  "#define ys cout<<\"YES\\n\"",
	  "#define no cout<<\"NO\\n\"",
	  "#define deb1(x) cout << #x << \"=\" << x << endl",
      "#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl",
	  "#define fout(x) fixed<<setprecision(x)",
     
	  "",
	  "//Fast IO",
	  "#define fast ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0)",
	  
	  "//Mathmatical Functions",
	  "inline ll GCD(ll a, ll b) { return b == 0 ? a : GCD(b, a % b); }",
      "inline ll LCM(ll a, ll b) { return a * b / GCD(a, b); }",
	  "inline double logb(ll base,ll num){ return (double)log(num)/(double)log(base);}",
      "inline bool isPowerOfTwo(ll n){if(n<=0)return false;return (ceil(log2(n)) == floor(log2(n)));}",
	  "inline bool isPerfectSquare(ll x){if (x >= 0) {ll sr = sqrt(x);return (sr * sr == x);}return false;}",

      "",
	  "//Operator Overloads",
	  "template<typename T1, typename T2> // cin >> pair<T1, T2>",
	  "istream& operator>>(istream &istream, pair<T1, T2> &p) { return (istream >> p.ff >> p.ss); }",
	  "template<typename T> // cin >> vector<T>",
	  "istream& operator>>(istream &istream, vector<T> &v){for (auto &it : v)cin >> it;return istream;}",
	  "template<typename T1, typename T2> // cout << pair<T1, T2>",
	  "ostream& operator<<(ostream &ostream, const pair<T1, T2> &p) { return (ostream << p.ff << \" \" << p.ss); }",
	  "template<typename T> // cout << vector<T>",
	  "ostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }",
	  "template<typename T1,typename T2>//cin>>vector<pair<T1,T2>>",
      "istream& operator>>(istream &istream,vector<pair<T1,T2>>&v){for(int i=0;i<sz(v);i++)istream>>v[i].ff>>v[i].ss;return istream;}",
      "template<typename T1,typename T2>//cout<<vector<pair<T1,T2>>",
      "ostream& operator<<(ostream &ostream,const vector<pair<T1,T2>>&v){for(auto &it:v)ostream<<it.ff<<\" \"<<it.ss<<nl;return ostream;}",
	  "",
	  "//Debug",
	  "#ifdef Debug",
	  "#define debug(x) cerr << #x<<\" \"; cerr<<x<<\" \"; cerr << endl;",
	  "#else",
	  "#define debug(x);",
	  "#endif",
      "",
	  "void setIO()",
	  "{",
	  "    #ifndef ONLINE_JUDGE",
	  "        freopen(\"input.txt\",\"r\",stdin);",
	  "        freopen(\"output.txt\",\"w\",stdout);",
	  "    #endif",
	  "}",
	  "",
	  "//Constants",
	  "#define pi acos(-1)",
	  "const double eps = 1e-6;",
	  "const int N=1e5+10;",
	  "const int M=1e9+7;",
	  "const ll INF= LONG_LONG_MAX;",
      "",
	  "void solve()",
	  "{",
	  "    ",
	  "}",
	  "int main()",
	  "{",
	  "    fast;",
	  "    //setIO();",
	  "    int t=1;",
	  "    //cin>>t;",
	  "    while(t--)",
	  "    {",
	  "      solve();",
	  "    }",
	  "    return 0;",
	  "}"
	],
	"description": "This is a boilerplate code"
  }
  "Chinese Remainder": {
	"prefix": "Crt",
	"body": [
	  "// *************CHINESE REMAINDER THEOREM*************",
	  "int s, t, gcd;",
	  "void Gcd(int a, int b)",
	  "{",
	  "    if (!b)",
	  "    {",
	  "        s = 1;",
	  "        t = 0;",
	  "        gcd = a;",
	  "    }",
	  "    else",
	  "    {",
	  "        Gcd(b, a % b);",
	  "        int temp = s;",
	  "        s = t;",
	  "        t = temp - t * (a / b);",
	  "    }",
	  "}",
	  "void solve()",
	  "{",
	  "    int n, M = 1, ans = 0;",
	  "    cin >> n;",
	  "    vector<pair<int, int>> v;",
	  "    vector<int> Mi, Y;",
	  "    for (int i = 0; i < n; i++)",
	  "    {",
	  "        int x, m;",
	  "        cin >> x >> m;",
	  "        v.push_back({x, m});",
	  "        M *= m;",
	  "    }",
	  "    for (auto &x : v)",
	  "        Mi.push_back(M / x.second);",
	  "    for (int i = 0; i < n; i++)",
	  "    {",
	  "        Gcd(Mi[i], v[i].second);",
	  "        Y.push_back(s);",
	  "    }",
	  "    for (int i = 0; i < n; i++)",
	  "        ans += (v[i].first * Mi[i] * Y[i]);",
	  "    cout << ans % M << endl;",
	  "}"
	],
	"description": "Chinese Remainder"
  }
  "Fermat's Little ": {
	"prefix": "Fermat",
	"body": [
	  "//************PSEUDOPRIME************",
	  "vector<int> pfactors;",
	  "void Factors(int n)",
	  "{",
	  "    for (int i = 2; i * i <= n; i++)",
	  "    {",
	  "        while (!(n % i))",
	  "        {",
	  "            pfactors.pb(i);",
	  "            n /= i;",
	  "        }",
	  "    }",
	  "    if (n > 1)",
	  "        pfactors.pb(n);",
	  "}",
	  "void solve()",
	  "{",
	  "    int b, n;",
	  "    cin >> b >> n;",
	  "    Factors(n);",
	  "    for (auto &x : pfactors)",
	  "    {",
	  "        int power = (n - 1) % (x - 1), p = pow(b, power);",
	  "        if (p % x != 1)",
	  "        {",
	  "            cout << \"Not a Pseudoprime\\n\";",
	  "            return;",
	  "        }",
	  "    }",
	  "    cout << n << \" is a pseudoprime of base \" << b << endl;",
	  "}"
	],
	"description": "Fermat's Little "
  }
  "Next Combination": {
	"prefix": "Next_Combination",
	"body": [
	  "void solve()",
	  "{",
	  "    int n, r, ct = 0, k, p;",
	  "    cin >> n >> r;",
	  "    vector<int> s(n), d(r);",
	  "    for (int i = 0; i < n; i++)",
	  "        cin >> s[i];",
	  "    for (int i = 0; i < r; i++)",
	  "        cin >> d[i];",
	  "    int j = r - 1;",
	  "    for (int i = n - 1; i >= 0; i--)",
	  "    {",
	  "        if (d[j] == s[i])",
	  "        {",
	  "            ct++;",
	  "            j--;",
	  "        }",
	  "        else",
	  "        {",
	  "            ct++;",
	  "            k = d[j];",
	  "            break;",
	  "        }",
	  "    }",
	  "    for (int i = 0; i < n; i++)",
	  "    {",
	  "        if (k == s[i])",
	  "        {",
	  "            p = i;",
	  "            break;",
	  "        }",
	  "    }",
	  "    deb1(p);",
	  "    if (ct == r)",
	  "    {",
	  "        for (int i = p + 1; ct; i++)",
	  "        {",
	  "            cout << s[i] << \" \";",
	  "            ct--;",
	  "        }",
	  "    }",
	  "    else",
	  "    {",
	  "        for (int i = 0; i < r - ct; i++)",
	  "            cout << d[i] << \" \";",
	  "        for (int i = p + 1; ct; i++)",
	  "        {",
	  "            cout << s[i] << \" \";",
	  "            ct--;",
	  "        }",
	  "    }",
	  "}"
	],
	"description": "Next Combination"
  }
  "RSA Encryption": {
	"prefix": "RSA",
	"body": [
	  "//*********RSA ENCRYPTION***********",
	  "int modInverse(int a, int m)",
	  "{",
	  "    for (int i = 1; i < m; i++)",
	  "        if (((a % m) * (i % m)) % m == 1)",
	  "            return i;",
	  "}",
	  "int binExpIter(int a, int b, int m)",
	  "{",
	  "    int ans = 1;",
	  "    while (b)",
	  "    {",
	  "        if (b & 1)",
	  "            ans = (ans * a) % m;",
	  "        a = (a * a) % m;",
	  "        b >>= 1;",
	  "    }",
	  "    return ans;",
	  "}",
	  "void solve()",
	  "{",
	  "    int p = 11, q = 17, pq = p * q, phi = (p - 1) * (q - 1), cp = 3;",
	  "    int modInv = modInverse(cp, phi);",
	  "    int x;",
	  "    cin >> x;",
	  "    int y = (x * x * x) % pq;",
	  "    int z = binExpIter(y, modInv, pq);",
	  "    cout << z << nl;",
	  "}"
	],
	"description": "RSA Encryption"
  }
  "Next Permutation": {
	"prefix": "Next_Permutation",
	"body": [
	  "void solve()",
	  "{",
	  "    string s;",
	  "    cin >> s;",
	  "    int i = s.size() - 2;",
	  "    for (; i >= 0; i--)",
	  "        if (s[i] - '0' < s[i + 1] - '0')",
	  "            break;",
	  "    for (int j = s.size() - 1; j > i; j--)",
	  "    {",
	  "        if (s[j] - '0' > s[i] - '0')",
	  "        {",
	  "            swap(s[i], s[j]);",
	  "            break;",
	  "        }",
	  "    }",
	  "    reverse(s.begin() + i + 1, s.end());",
	  "    cout << \"Next Permutation:\" << s << nl;",
	  "}"
	],
	"description": "Next Permutation"
  }
  "bezout": {
	"prefix": "bezout",
	"body": [
	  "int s, t, gcd;",
	  "void Gcd(int a, int b)",
	  "{",
	  "    if (!b)",
	  "    {",
	  "        s = 1;",
	  "        t = 0;",
	  "        gcd = a;",
	  "    }",
	  "    else",
	  "    {",
	  "        Gcd(b, a % b);",
	  "        int temp = s;",
	  "        cout << a << \" \" << b << \" \" << s << \" \" << t << nl;",
	  "        s = t;",
	  "        t = temp - t * (a / b);",
	  "    }",
	  "}"
	],
	"description": "bezout"
  }
  "Prime": {
	"prefix": "Prime",
	"body": [
	  "vi k(N, 1);",
	  "void primes()",
	  "{",
	  "    k[0] = k[1] = 0;",
	  "    fo(i, 2, N)",
	  "    {",
	  "        if (k[i])",
	  "            for (int j = 2 * i; j < N; j += i)",
	  "                k[j] = 0;",
	  "    }",
	  "}"
	],
	"description": ""
  }
  "binSearch": {
	"prefix": "binSearch",
	"body": [
	  "int binsearch(vi &v, int x)",
	  "{",
	  "    int lo = 0, hi = sz(v) - 1;",
	  "    while (hi - lo > 1)",
	  "    {",
	  "        int mid = (lo + hi) / 2;",
	  "        if (v[mid] < x)",
	  "            lo = mid + 1;",
	  "        else",
	  "            hi = mid;",
	  "    }",
	  "    if (v[lo] == x)",
	  "        return lo;",
	  "    else if (v[hi] == x)",
	  "        return hi;",
	  "    else",
	  "        return -1;",
	  "}"
	],
	"description": ""
  }
  "cmp": {
	"prefix": "cmp",
	"body": [
	  "bool cmp(pii a, pii b)",
	  "{",
	  "    if (a.ff != b.ff)",
	  "        return a.ff < b.ff;",
	  "    else",
	  "        return a.ss > b.ss;",
	  "}"
	],
	"description": ""
  }
  "InsertionSort": {
	"prefix": "InsertionSort",
	"body": [
	  "void insertion(vi &v)",
	  "{",
	  "	fo(i, 1, sz(v))",
	  "	{",
	  "		int key = v[i], j = i - 1;",
	  "		while (j >= 0 and v[j] > key)",
	  "		{",
	  "			v[j + 1] = v[j];",
	  "			--j;",
	  "		}",
	  "		v[++j] = key;",
	  "	}",
	  "}"
	],
	"description": ""
  }
  "SelectionSort": {
	"prefix": "SelectionSort",
	"body": [
	  "void Selection(vi &v)",
	  "{",
	  "    fo(i, 0, sz(v) - 1)",
	  "    {",
	  "        int k = i;",
	  "        fo(j, i + 1, sz(v)) if (v[j] < v[k]) k = j;",
	  "        swap(v[i], v[k]);",
	  "    }",
	  "}"
	],
	"description": ""
  }
  "BubbleSort": {
	"prefix": "BubbleSort",
	"body": [
	  "void BubbleSort(vi &v)",
	  "{",
	  "    fo(i, 0, sz(v)-1) fo(j, i + 1, sz(v)) if (v[i] > v[j]) swap(v[i], v[j]);",
	  "}"
	],
	"description": ""
  }
  "QuickSort": {
	"prefix": "QuickSort",
	"body": [
	  "int Partition(vi &v, int l, int r)",
	  "{",
	  "    int x = v[r], j = l - 1;",
	  "    fo(i, l, r)",
	  "    {",
	  "        if (v[i] <= x)",
	  "        {",
	  "            j++;",
	  "            swap(v[j], v[i]);",
	  "        }",
	  "    }",
	  "    swap(v[j + 1], v[r]);",
	  "    return j + 1;",
	  "}",
	  "void QuickSort(vi &v, int l, int r)",
	  "{",
	  "    if (l >= r)",
	  "        return;",
	  "    int pivot = Partition(v, l, r);",
	  "    QuickSort(v, l, pivot - 1);",
	  "    QuickSort(v, pivot + 1, r);",
	  "}"
	],
	"description": ""
  }
  "MergeSort": {
	"prefix": "MergeSort",
	"body": [
	  "int b[N];",
	  "void merge(int *v, int l, int mid, int h)",
	  "{",
	  "    int i = l, k = l, j = mid + 1;",
	  "    while (i <= mid and j <= h)",
	  "    {",
	  "        if (v[i] > v[j])",
	  "        {",
	  "            b[k] = v[j];",
	  "            k++;",
	  "            j++;",
	  "        }",
	  "        else",
	  "        {",
	  "            b[k] = v[i];",
	  "            k++;",
	  "            i++;",
	  "        }",
	  "    }",
	  "    while (i <= mid)",
	  "    {",
	  "        b[k] = v[i];",
	  "        k++;",
	  "        i++;",
	  "    }",
	  "    while (j <= h)",
	  "    {",
	  "        b[k] = v[j];",
	  "        k++;",
	  "        j++;",
	  "    }",
	  "    fo(i, l, h + 1) v[i] = b[i];",
	  "}",
	  "void MS(int *v, int l, int h)",
	  "{",
	  "    int mid = (l + h) / 2;",
	  "    if (l < h)",
	  "    {",
	  "        MS(v, l, mid);",
	  "        MS(v, mid + 1, h);",
	  "        merge(v, l, mid, h);",
	  "    }",
	  "}"
	],
	"description": ""
  }
  "HeapSort": {
	"prefix": "HeapSort",
	"body": [
	  "void Heapify(int *a, int n, int i)",
	  "{",
	  "    int largest = i, lc = 2 * i + 1, rc = 2 * i + 2;",
	  "    if (lc < n && a[lc] > a[largest])",
	  "    {",
	  "        largest = lc;",
	  "    }",
	  "    if (rc < n && a[rc] > a[largest])",
	  "    {",
	  "        largest = rc;",
	  "    }",
	  "    if (i != largest)",
	  "    {",
	  "        swap(a[i], a[largest]);",
	  "        Heapify(a, n, largest);",
	  "    }",
	  "}",
	  "void HeapSort(int *a, int n)",
	  "{",
	  "    for (int i = (n / 2) - 1; i >= 0; i--)",
	  "        Heapify(a, n, i);",
	  "    for (int i = n - 1; i >= 0; i--)",
	  "    {",
	  "        swap(a[0], a[i]);",
	  "        Heapify(a, i, 0);",
	  "    }",
	  "}"
	],
	"description": ""
  }
  "binExpIter": {
	"prefix": "binExpIter",
	"body": [
	  "ll binExpIter(ll a, ll b)",
	  "{",
	  "    ll ans = 1;",
	  "    while (b)",
	  "    {",
	  "        if (b & 1)",
	  "            ans *= a;",
	  "        a *= a;",
	  "        b >>= 1;",
	  "    }",
	  "    return ans;",
	  "}"
	],
	"description": ""
  }
  "binExpRecur": {
	"prefix": "binExpRecur",
	"body": [
	  "ll binExpRecur(ll a, ll b)",
	  "{",
	  "    if (b == 0)",
	  "        return 1;",
	  "    ll ans = binExpRecur(a, b / 2);",
	  "    if (b & 1)",
	  "        return (a * ans * ans) % M;",
	  "    else",
	  "        return (ans * ans) % M;",
	  "}"
	],
	"description": ""
  }
  "binMul": {
	"prefix": "binMul",
	"body": [
	  "ll binMul(ll a, ll b)",
	  "{",
	  "    ll ans = 0;",
	  "    while (b)",
	  "    {",
	  "        if (b & 1)",
	  "            ans += a;",
	  "        a += a;",
	  "        b >>= 1;",
	  "    }",
	  "    return ans;",
	  "}"
	],
	"description": ""
  }
  "BinaryString": {
	"prefix": "BinaryString",
	"body": [
	  "string binary(int n)",
	  "{",
	  "    string s;",
	  "    re(i, 31, 0)(n & (1 << i)) ? s.pb('1') : s.pb('0');",
	  "    return s;",
	  "}"
	],
	"description": ""
  }
  "PrimeFactors": {
	"prefix": "PrimeFactors",
	"body": [
	  "vll pfactors;",
	  "void factors(ll n)",
	  "{",
	  "    for (int i = 2; i * i <= n; i++)",
	  "    {",
	  "        while (!(n % i))",
	  "        {",
	  "            pfactors.pb(i);",
	  "            n /= i;",
	  "        }",
	  "    }",
	  "    if (n > 1)",
	  "        pfactors.pb(n);",
	  "}"
	],
	"description": ""
  }
  "HLPrime": {
	"prefix": "HLPrime",
	"body": [
	  "vll hp(N, 0), lp(N, 0);",
	  "void hlprimes()",
	  "{",
	  "    k[0] = k[1] = 0;",
	  "    fo(i, 2, N)",
	  "    {",
	  "        if (k[i])",
	  "        {",
	  "            lp[i] = i;",
	  "            hp[i] = i;",
	  "            for (int j = 2 * i; j < N; j += i)",
	  "            {",
	  "                k[j] = 0;",
	  "                hp[j] = i;",
	  "                if (lp[j] == 0)",
	  "                    lp[j] = i;",
	  "            }",
	  "        }",
	  "    }",
	  "}"
	],
	"description": ""
  }
  "Factorial": {
	"prefix": "Factorial",
	"body": [
	  "ll fact(ll n)",
	  "{",
	  "    if (n == 0)",
	  "        return 1;",
	  "    return (n * fact(n - 1));",
	  "}"
	],
	"description": ""
  }
  "": {
	"prefix": "Template",
	"body": [
	  "#include <bits/stdc++.h>",
	  "#include<ext/pb_ds/assoc_container.hpp>",
	  "#include<ext/pb_ds/tree_policy.hpp>",
	  "#pragma GCC optimize(\"Ofast,unroll-loops\")",
	  "typedef long long ll;",
	  "typedef long double ld;",
	  "typedef unsigned long long ull;",
	  "#define umap unordered_map",
	  "#define uset unordered_set",
	  "#define sz(v) (int)v.size()",
	  "#define mem(a,x) memset(a,x,sizeof(a))",
	  "#define vi vector<int>",
	  "#define vll vector<ll>",
	  "#define vvi vector<vi>",
	  "#define vvl vector<vl>",
	  "#define vs vector<string>",
	  "#define pii pair<int,int>",
	  "#define pll pair<ll,ll>",
	  "#define vpii vector<pii>",
	  "#define vpll vector<pll>",
	  "#define mi map<int,int>",
	  "#define pi acos(-1)",
	  "#define nl '\\n'",
	  "#define pb push_back",
	  "#define eb emplace_back",
	  "#define pob pop_back",
	  "#define pf pop_front",
	  "#define mp make_pair",
	  "#define fo(i,a,b) for(int i=a;i<b;++i)",
	  "#define re(i,a,b) for(int i=a;i>=b;--i)",
	  "#define itr(it, v) for(auto it = v.begin(); it != v.end(); it++)",
	  "#define fr(x, v) for(auto &x:v)",
	  "#define deb(x) cout << #x << \"=\" << x << endl",
      "#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl",
	  "#define ff first",
	  "#define ss second",
	  "#define ys cout<<\"YES\\n\"",
	  "#define no cout<<\"NO\\n\"",
	  "#define fast ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0)",
	  "#define all(v) v.begin(),v.end()",
	  "#define rev(v) reverse(all(v))",
	  "#define srt(v) sort(all(v))",
	  "#define grtsrt(v) sort(all(v),greater<ll>())",
	  "#define tl(v)  transform(all(v),v.begin(),::tolower)",
	  "#define tu(v)  transform(all(v),v.begin(),::toupper)",
	  "#define lb(v,x) *lower_bound(all(v),x)",
	  "#define ub(v,x) *upper_bound(all(v),x)",
	  "#define mn(v) *min_element(all(v))",
	  "#define mx(v) *max_element(all(v))",
	  "#define mxa(a,n) *max_element(a,a+n)",
	  "#define mna(a,n) *min_element(a,a+n)",
	  "#define one(x) __builtin_popcountll(x)",
	  "#define fout(x) fixed<<setprecision(x)",
	  "#define set_bit(x,k) (x|=(1LL<<k))",
	  "#define uset_bit(x,k) (x &= ~(1LL<<k))",
	  "#define check_bit(x,k) (x & (1LL<<k))",
	  "#define toggle_bit(x,k) (x ^ (1LL<<k))",
	  "inline ll GCD(ll a, ll b) { return b == 0 ? a : GCD(b, a % b); }",
      "inline ll LCM(ll a, ll b) { return a * b / GCD(a, b); }",
	  "inline double logb(ll base,ll num){ return (double)log(num)/(double)log(base);}",
	  "#define mod 1000000007",
	  "const double eps = 1e-6;",
	  "const int N=1e5+10;",
	  "const int M=1e9+7;",
	  "using namespace std;",
	  "using namespace __gnu_pbds;\n",
	  "void setIO(){",
	  "    #ifndef ONLINE_JUDGE",
	  "        freopen(\"input.txt\",\"r\",stdin);",
	  "        freopen(\"output.txt\",\"w\",stdout);",
	  "    #endif",
	  "}",
	  "template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }",
	  "template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }",
	  "void dbg_out() { cerr << endl; }",
	  "template<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }",
	  "#ifdef LOCAL",
	  "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
	  "#else",
	  "#define dbg(...)",
	  "#endif",
	  "",
	  "#define ar array",
	  "#define ll long long",
	  "#define ld long double",
	  "#define sza(x) ((int)x.size())",
	  "#define all(a) (a).begin(), (a).end()",
	  "",
	  "#define PI 3.1415926535897932384626433832795l ",
	  "const int MAX_N = 1e5 + 5;",
	  "const ll MOD = 1e9 + 7;",
	  "const ll INF = 1e9;",
	  "const ld EPS = 1e-9;",
	  "",
	  "// -------------------------<RNG>------------------------- ",
	  "// RANDOM NUMBER GENERATOR",
	  "mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());  ",
	  "#define SHUF(v) shuffle(all(v), RNG); ",
	  "// Use mt19937_64 for 64 bit random numbers.",
	  "",
	  "// ----------------------</BITWISE>-------------------------- ",
	  "/* a=target variable, b=bit number to act upon 0-n */",
	  "#define BIT_SET(a,b) ((a) |= (1ULL<<(b)))",
	  "#define BIT_CLEAR(a,b) ((a) &= ~(1ULL<<(b)))",
	  "#define BIT_FLIP(a,b) ((a) ^= (1ULL<<(b)))",
	  "",
	  "// '!!' to make sure this returns 0 or 1",
	  "#define BIT_CHECK(a,b) (!!((a) & (1ULL<<(b))))",
	  "",
	  "#define BITMASK_SET(x, mask) ((x) |= (mask))",
	  "#define BITMASK_CLEAR(x, mask) ((x) &= (~(mask)))",
	  "#define BITMASK_FLIP(x, mask) ((x) ^= (mask))",
	  "#define BITMASK_CHECK_ALL(x, mask) (!(~(x) & (mask)))",
	  "#define BITMASK_CHECK_ANY(x, mask) ((x) & (mask))",
	  "// ----------------------</BITWISE END>-------------------------- ",
	  "",
	  "// ----------------------<MATH>--------------------------- ",
	  " ",
	  "template<typename T> T gcd(T a, T b){return(b?__gcd(a,b):a);} ",
	  "",
	  "template<typename T> T lcm(T a, T b){return(a*(b/gcd(a,b)));} ",
	  "",
	  "int add(int a, int b, int c = MOD){int res=a+b;",
	  "                         return(res>=c?res-c:res);} ",
	  "int mod_neg(int a, int b, int c = MOD){int res;",
	  "                         if(abs(a-b)<c)res=a-b;else res=(a-b)%c;",
	  "                         return(res<0?res+c:res);} ",
	  "int mul(int a, int b, int c = MOD){ll res=(ll)a*b;",
	  "                         return(res>=c?res%c:res);} ",
	  "int muln(int a, int b, int c = MOD){ll res=(ll)a*b;",
	  "                         return ((res%c)+c)%c;} ",
	  "ll mulmod(ll a,ll b, ll m = MOD){ll q = (ll)(((LD)a*(LD)b)/(LD)m);",
	  "                         ll r=a*b-q*m;if(r>m)r%=m;if(r<0)r+=m;return r;} ",
	  "template<typename T>T expo(T e, T n){T x=1,p=e;while(n)",
	  "                         {if(n&1)x=x*p;p=p*p;n>>=1;}return x;} ",
	  "template<typename T>T power(T e, T n, T m = MOD){T x=1,p=e;while(n)",
	  "                      {if(n&1)x=mul(x,p,m);p=mul(p,p,m);n>>=1;}return x;} ",
	  "template<typename T>T extended_euclid(T a, T b, T &x, T &y)",
	  "                    {T xx=0,yy=1;y=0;x=1;while(b){T q=a/b,t=b;b=a%b;a=t;\\ ",
	  "t=xx;xx=x-q*xx;x=t;t=yy;yy=y-q*yy;y=t;}return a;}",
	  "template<typename T>T mod_inverse(T a, T n = MOD){T x,y,z=0;",
	  "               T d=extended_euclid(a,n,x,y);return(d>1?-1:mod_neg(x,z,n));} ",
	  "  ",
	  "// Permutation and Combination",
	  "int ncr(int n,int r,int c = MOD){ ",
	  "    return mul(mul(ifact[r],ifact[n-r],c),fact[n],c); ",
	  "}  ",
	  "",
	  "// ----------------------</MATH>-------------------------- ",
	  "",
	  "/****************** Prime Generator **********************/ ",
	  "const int N=1e7+10; int prime[20000010]; ",
	  "bool isprime[N]; int nprime; ",
	  "template <typename T> void Sieve(T a) ",
	  "{nprime = 0;memset(isprime,true,sizeof(isprime));",
	  "isprime[1]=false;for(int i=2;i<N;i++){",
	  "if(isprime[i]){prime[nprime++]=i;for(int j=2;i*j<N;j++)",
	  "isprime[i*j]=false;}}}",
	  "",
	  "template <typename T> bool miller_rabin(T p, T itt) ",
	  "{if(p<2) return 0 ;if(p==2) return 1;if(p%2==0) ",
	  "return 0 ;ull s = p-1 ;while(s%2==0) s/=2;",
	  "for(ll i=1;i<=itt;i++) {ull a = rand() % (p-1)+1 , temp = s ;",
	  "ull mod = modulo(a,temp,(ull)p);while(mod!=1 and mod!=p-1 ",
	  "and temp!=p-1){mod = Mulmod(mod,mod,(ull)p);temp*=2;}",
	  "if(temp%2==0 and mod!=p-1) return false ;}return true;} ",
	  "",
	  "template <typename T> inline T PrimeFactors(T n)",
	  "{ll cnt=0,sum=1;for(int i=0; prime[i]*prime[i]<=n ",
	  "and i<nprime;i++){cnt=0;while(n%prime[i]==0)",
	  "{cnt++;n/=prime[i];}sum*=(cnt+1);}",
	  "if(n>1)sum*=2;return sum;} ",
	  "/****************** Prime Generator End **********************/ ",
	  "",
	  "/****************** Geometry *****************/ ",
	  "template <typename T> inline T PointDistanceHorVer(T x1,T y1,T x2, T y2) ",
	  "{return abs(x1-x2)+abs(y1-y2);} ",
	  "template <typename T> inline T PointDistanceDiagonally(T x1,T y1,T x2, T y2) ",
	  "{return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));} ",
	  "template <typename T> inline T PointDistanceMinimum(T x1,T y1,T x2, T y2) ",
	  "{ T tmp1=abs(x1-x2); T tmp2=abs(y1-y2); T tmp3=abs(tmp1-tmp2); ",
	  "T tmp4=min(tmp1, tmp2); return tmp3+tmp4; } ",
	  "template <typename T> inline T PointDistance3D(T x1,T y1,T z1,T x2,T y2,T z2)",
	  "{return sqrt(square(x2-x1)+square(y2-y1)+square(z2-z1));} ",
	  " ",
	  "template <typename T> inline T Cube(T a){return a*a*a;} ",
	  "template <typename T> inline T RectengularPrism(T a,T b,T c)",
	  "{return a*b*c;} ",
	  "template <typename T> inline T Pyramid(T base, T height)",
	  "{return (1/3)*base*height;} ",
	  "template <typename T> inline T Ellipsoid(T r1,T r2,T r3) ",
	  "{return (4/3)*PI*r1*r2*r3;} ",
	  "template <typename T> inline T IrregualarPrism(T base, T height)",
	  "{return base*height;} ",
	  "template <typename T> inline T Sphere(T radius)",
	  "{ return (4/3)*PI*radius*radius*radius;} ",
	  "template <typename T> inline T CylinderB(T base, T height)",
	  "{return base*height;} // base and height ",
	  "template <typename T> inline T CylinderR(T radius, T height)",
	  "{return PI*radius*radius*height;} // radius and height ",
	  "template <typename T> inline T Cone (T radius,T base, T height)",
	  "{return (1/3)*PI*radius*radius*height;} ",
	  "/****************** Geometry end *****************/ ",
	  "",
	  "void solve()",
	  "{",
	  "",
	  "}",
	  "",
	  "int main()",
	  "{",
	  "    ios_base::sync_with_stdio(0);",
	  "    cin.tie(0); cout.tie(0);",
	  "    int tc = 1;",
	  "    // cin >> tc;",
	  "    while(tc--) {",
	  "        solve();",
	  "    }",
	  "}",
	  ""
	],
	"description": ""
  }
}
